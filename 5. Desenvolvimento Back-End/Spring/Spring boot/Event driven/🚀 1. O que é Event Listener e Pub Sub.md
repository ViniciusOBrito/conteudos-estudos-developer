## 1. O que é um Event Listener em Java?

É basicamente a implementação do **padrão Observer**:

- **Event Source (fonte de eventos)**: objeto que gera o evento (ex: botão, serviço, servidor, etc.).
- **Listener (ouvinte)**: objeto que “assina” o evento e é notificado quando algo acontece.
- **Event (objeto de evento)**: contém dados sobre o que aconteceu (quem disparou, horário, payload, etc.).

Em Java isso é MUITÍSSIMO comum em:

- Swing / AWT (`ActionListener`, `MouseListener`, etc.)
- Servlets (`ServletContextListener`, `HttpSessionListener`)
- APIs de mensageria, Sockets, etc.

---

## 2. Estrutura básica de um Event Listener “do zero”

Vamos montar um exemplo completo e simples:

### 2.1. Classe de evento

```java
public class PedidoCriadoEvent {
    private final String codigoPedido;
    private final double valorTotal;

    public PedidoCriadoEvent(String codigoPedido, double valorTotal) {
        this.codigoPedido = codigoPedido;
        this.valorTotal = valorTotal;
    }

    public String getCodigoPedido() {
        return codigoPedido;
    }

    public double getValorTotal() {
        return valorTotal;
    }
}

```

> Dica: eventos costumam ser imutáveis (final + sem setters).

---

### 2.2. Interface do listener

```java
public interface PedidoListener {
    void onPedidoCriado(PedidoCriadoEvent event);
}

```

Você pode ter vários métodos (um por tipo de evento) ou uma interface por evento, depende do design.

---

### 2.3. Fonte de eventos (Event Source)

```java
import java.util.ArrayList;
import java.util.List;

public class PedidoService {

    private final List<PedidoListener> listeners = new ArrayList<>();

    public void addListener(PedidoListener listener) {
        listeners.add(listener);
    }

    public void removeListener(PedidoListener listener) {
        listeners.remove(listener);
    }

    // Método de negócio que dispara o evento
    public void criarPedido(String codigo, double valorTotal) {
        // ... regra de negócio: validação, persistência, etc.

        // Depois de criar, dispara o evento
        PedidoCriadoEvent event = new PedidoCriadoEvent(codigo, valorTotal);
        notificarPedidoCriado(event);
    }

    private void notificarPedidoCriado(PedidoCriadoEvent event) {
        // Notifica todos os listeners registrados
        for (PedidoListener listener : listeners) {
            try {
                listener.onPedidoCriado(event);
            } catch (Exception e) {
                // MUITO IMPORTANTE: não deixar uma exception matar todos os outros listeners
                e.printStackTrace();
            }
        }
    }
}

```

---

### 2.4. Implementando um listener

```java
public class EmailPedidoListener implements PedidoListener {

    @Override
    public void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("Enviando e-mail para pedido " + event.getCodigoPedido() +
                " com valor " + event.getValorTotal());
        // lógica para disparar e-mail...
    }
}

```

### 2.5. Registrando o listener e usando

```java
public class Main {
    public static void main(String[] args) {
        PedidoService pedidoService = new PedidoService();

        // Registra os listeners
        pedidoService.addListener(new EmailPedidoListener());
        pedidoService.addListener(event ->
                System.out.println("Log: pedido criado = " + event.getCodigoPedido())
        ); // usando lambda porque PedidoListener é uma interface funcional

        // Cria um pedido
        pedidoService.criarPedido("PED-001", 150.0);
    }
}

```

---

## 3. Boas práticas ao implementar Listeners

1. **Evento imutável**
    - Facilita depuração e evita estado mutável bizarro sendo alterado por vários listeners.
2. **Não bloquear a thread principal**
    - Se o listener fizer coisa pesada (chamar API, acessar banco, enviar e-mail), considere:
        - Executar em outra thread (`ExecutorService`, `CompletableFuture`, etc.).
        - Ou usar um framework reativo / fila (Kafka, RabbitMQ, etc.).
3. **Evitar vazamento de memória**
    - Sempre que tiver `addListener`, pense se precisa de `removeListener`.
    - Especialmente em aplicações de longa duração (servidores, desktop apps).
4. **Tratar exceções** dentro do loop de notificação
    - Senão um listener com erro derruba todos os outros.
5. **Não misturar regra de negócio com event wiring**
    - A classe de negócio dispara evento, listeners fazem “efeitos colaterais” (e-mail, log, integração).

---

## 4. Event-driven vs Programação Reativa

Agora a parte da sua pergunta: **programação reativa ou event driven**.

### 4.1. Event-driven (direta ao ponto)

“Event-driven” é um **estilo de arquitetura** onde:

- Coisas acontecem em resposta a **eventos**.
- Em vez de `main()` chamar tudo na sequência, você reage a:
    - clique de botão,
    - mensagem chegando numa fila,
    - mudança de estado,
    - requisições HTTP,
    - etc.

O pattern de **Event Listener** é um tijolo básico disso.

---

### 4.2. Programação Reativa

Programação reativa é um passo além:

- Em vez de pensar em “um evento”, você pensa em **fluxos de eventos** (streams).
- Você descreve um **pipeline de transformação**:
    - filtra, mapeia, faz debounce, agrupa, combina streams, etc.
- Suporta **backpressure** (o consumidor avisa pro produtor “calma, estou cheio”).
- Em Java, os principais são:
    - **Project Reactor** (`Flux`, `Mono`) – muito usado no Spring WebFlux.
    - **RxJava** (`Observable`, `Flowable`, etc.).
    - **Java Flow API (java.util.concurrent.Flow)** – padrão de Reactive Streams no JDK.

---

### 4.3. Comparando: Listener “clássico” vs Reativo

### Listener clássico (como vimos):

```java
pedidoService.addListener(event -> {
    System.out.println("Pedido criado: " + event.getCodigoPedido());
});

```

O `PedidoService` **controla quando** chama o listener.

---

### Fluxo reativo com Reactor (exemplo bem simples):

```java
import reactor.core.publisher.Flux;

import java.time.Duration;

public class ReactiveExample {
    public static void main(String[] args) throws InterruptedException {
        Flux<Integer> numeros = Flux.range(1, 10); // fluxo de 1 a 10

        numeros
            .filter(n -> n % 2 == 0)        // mantém pares
            .map(n -> n * n)               // quadrado
            .delayElements(Duration.ofMillis(500)) // emite a cada 500ms
            .subscribe(n -> System.out.println("Recebi: " + n));

        Thread.sleep(6000); // só para não encerrar a main antes das emissões
    }
}

```

Diferenças importantes:

- `Flux` é **lazy**: só começa a emitir quando alguém chama `subscribe`.
- Você monta um **pipeline declarativo** (filter/map/delay).
- A API já é preparada para **assíncrono**, **non-blocking** e **backpressure**.

---

## 5. Quando usar cada coisa?

### Listener “puro” (Observer clássico):

- Bom para:
    - Dentro de um mesmo serviço/aplicação.
    - Coisas simples de “evento + callback”.
    - Sistemas pequenos/médios sem grande carga de concorrência.
- Vantagem:
    - Simples, fácil de entender.
- Desvantagem:
    - Você mesmo gerencia thread, concorrência, backpressure, etc.

---

### Estilo reativo (Reactor, RxJava, etc):

- Bom para:
    - Sistemas que lidam com **muitos eventos** ou **I/O intenso** (HTTP, banco assíncrono, mensageria).
    - Integrações com WebFlux, RSocket, Kafka reativo, etc.
- Vantagem:
    - API pensada para **streams de eventos**, composição, paralelismo, backpressure.
- Desvantagem:
    - Curva de aprendizado maior.
    - Pode ser “overkill” para problemas simples.

---

## 6. Caminho prático pra você

Se você quer **sair dos if/else e callbacks soltos** e ir pra algo mais organizado:

1. **Comece dominando o padrão Listener/Observer** (o que fizemos acima).
2. Depois:
    - Brinque com **`CompletableFuture`** (assíncrono básico).
    - Depois dê uma olhada em **Project Reactor** (`Flux`, `Mono`).
3. Se estiver no mundo Spring:
    - Veja `ApplicationEvent` e `@EventListener` (Spring já tem um sistema de eventos bem bacana),
    - E depois Spring WebFlux / Reactor.

Se você quiser, no próximo passo posso:

- Pegar **um caso real seu** (ex: “quando criar cliente, disparar X coisas”)
- E te mostrar **duas versões**:
    - com listener simples
    - e uma visão reativa usando Reactor / Spring.****