# 

Ã‰ quando:

- **um serviÃ§o publica mensagens** (Publisher)
- **outros serviÃ§os recebem** (Subscribers)
- **nÃ£o hÃ¡ ligaÃ§Ã£o direta** entre eles

Ou seja:

âœ” o produtor nÃ£o sabe quem consome

âœ” o consumidor nÃ£o sabe quem produziu

âœ” o broker (Rabbit, Kafka) faz o meio-campo

---

# ğŸŸ¦ RABBITMQ â€” VISÃƒO GERAL

RabbitMQ usa o conceito de **Exchange â†’ Queue â†’ Consumer**:

```
Publisher â†’ Exchange â†’ Queue(s) â†’ Consumer(s)

```

- O publisher manda mensagem para uma _exchange_
- A exchange distribui as mensagens **para uma ou mais filas**
- Os consumidores leem das filas

### Tipos de Exchange:

- **direct** â€“ roteamento por chave
- **fanout** â€“ broadcast para todas as filas
- **topic** â€“ roteamento por padrÃµes (ex: `pedido.*`)
- **headers** â€“ baseado em cabeÃ§alhos

RabbitMQ Ã©:

- mensagens para **cada consumidor**
- alta flexibilidade
- excelente para microserviÃ§os
- forte no padrÃ£o **Work Queue**

---

# ğŸŸ© KAFKA â€” VISÃƒO GERAL

Kafka Ã© totalmente diferente:

- Ele armazena mensagens em **logs particionados**
- Consumidores leem no seu prÃ³prio ritmo
- Mensagens **nÃ£o desaparecem** apÃ³s consumidas
- Ã‰ ultra performÃ¡tico para **milhares/milhÃµes** de mensagens

Modelo:

```
Producer â†’ Topic â†’ Partitions â†’ Consumer Group(s)

```

Kafka Ã©:

- ideal para processos crÃ­ticos
- sistemas de streaming em tempo real
- analytics, eventos de domÃ­nio, logs, pipelines

---

# ğŸ§  DIFERENÃ‡A CURTA (DECORAR):

|RabbitMQ|Kafka|
|---|---|
|Sistema tradicional de filas|Plataforma de streaming distribuÃ­do|
|Mensagem some apÃ³s leitura|Mensagem fica armazenada|
|Focado em mensagens pequenas e rÃ¡pidas|Focado em throughput e volume alto|
|Entrega garantida|Escalabilidade massiva|
|Ideal microserviÃ§os|Ideal analytics + eventos + integraÃ§Ã£o grande|

---

# ğŸ”µ 2. RABBITMQ NA PRÃTICA (JAVA)

Vamos usar a lib oficial **amqp-client**.

## DependÃªncia Maven:

```xml
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.17.0</version>
</dependency>

```

---

## ğŸ“¨ PRODUCER â€” Enviando mensagem

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class RabbitProducer {
    private final static String QUEUE = "fila.pedidos";

    public static void main(String[] args) throws Exception {

        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            channel.queueDeclare(QUEUE, false, false, false, null);

            String mensagem = "Pedido criado! ID=123";
            channel.basicPublish("", QUEUE, null, mensagem.getBytes());

            System.out.println("ğŸ“¤ Enviado: " + mensagem);
        }
    }
}

```

---

## ğŸ“¥ CONSUMER â€” Recebendo mensagem

```java
import com.rabbitmq.client.*;

public class RabbitConsumer {
    private final static String QUEUE = "fila.pedidos";

    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.queueDeclare(QUEUE, false, false, false, null);

        DeliverCallback callback = (consumerTag, delivery) -> {
            String mensagem = new String(delivery.getBody());
            System.out.println("ğŸ“¨ Recebido: " + mensagem);
        };

        channel.basicConsume(QUEUE, true, callback, consumerTag -> {});
    }
}

```

---

# ğŸŸ© 3. KAFKA NA PRÃTICA (JAVA)

Vamos usar **Spring Kafka**, que facilita tudo.

## 1ï¸âƒ£ DependÃªncias Maven

```xml
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

```

---

# PRODUCER Kafka

```java
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class PedidoProducer {

    private final KafkaTemplate<String, String> kafkaTemplate;

    public PedidoProducer(KafkaTemplate<String, String> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void enviarMensagem(String mensagem) {
        kafkaTemplate.send("pedidos", mensagem);
        System.out.println("ğŸ“¤ enviado para Kafka: " + mensagem);
    }
}

```

---

# CONSUMER Kafka

```java
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class PedidoConsumer {

    @KafkaListener(topics = "pedidos", groupId = "grupo-pedidos")
    public void consumir(String mensagem) {
        System.out.println("ğŸ“¨ Kafka recebeu: " + mensagem);
    }
}

```

---

# ğŸ”¥ COMO FUNCIONA NAS COSTAS

## RABBITMQ

Cada consumidor lÃª **sua fila**, e a mensagem some.

```
[Exchange] â†’ [Queue 1] â†’ Consumer A
            â†’ [Queue 2] â†’ Consumer B

```

---

## KAFKA

Cada consumer group lÃª **sua prÃ³pria cÃ³pia** do tÃ³pico:

```
[Topic Pedidos]
 Partition 0 â€”â€”â†’ grupo-1
 Partition 1 â€”â€”â†’ grupo-1

 Partition 0 â€”â€”â†’ grupo-2
 Partition 1 â€”â€”â†’ grupo-2

```

Kafka escala simplesmente aumentando partiÃ§Ãµes.

---

# ğŸ§© QUANDO USAR CADA UM?

## ğŸŸ¦ RABBITMQ

Use quando:

- Garantia de entrega importa
- Ordem importa
- Ã‰ microserviÃ§o pequeno/mÃ©dio
- Tasks assÃ­ncronas

Ex:

Enviar email, processar pagamento, notificaÃ§Ãµes.

---

## ğŸŸ© KAFKA

Use quando:

- Muitos eventos (milhÃµes)
- Alta performance
- Precisa manter histÃ³rico
- Event Sourcing / DDD

Ex:

Logs, telemetria, analytics, pipeline de dados.

---

# ğŸ¯ Resumo Final (estilo â€œcola de paredeâ€)

|Recurso|RabbitMQ|Kafka|
|---|---|---|
|Garantia de entrega|Ã“timo|Muito bom|
|HistÃ³rico|âŒ NÃ£o|âœ” Completo|
|Escalabilidade|Boa|**Insana**|
|Uso em microsserviÃ§os|âœ” Sim|âœ” Sim (grandes)|
|Ideal para|Tarefas assÃ­ncronas|Streaming e Big Data|
|Modelo|Filas|Logs particionados|