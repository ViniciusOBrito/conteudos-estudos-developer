Os **padrões de projeto** (design patterns) clássicos da GoF são tipicamente agrupados em três grandes categorias: **padrões criacionais**, **padrões estruturais** e **padrões comportamentais**. Cada grupo enfoca um aspecto diferente do design de software – desde a **criação de objetos**, passando pela **composição/organização de classes e objetos**, até a **colaboração e comunicação entre objetos**[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20de%20design%20s%C3%A3o,reutiliz%C3%A1veis%20e%20f%C3%A1ceis%20de%20manter)[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=The%20Gang%20of%20Four%20,offs%20involved%2C%20and%20representative%20patterns). A seguir, exploramos em detalhes cada categoria, com analogias do mundo real, exemplos (em pseudocódigo/Java) e cenários que mostram claramente quando cada grupo de padrões é mais apropriado.

## Padrões Criacionais (Creational Patterns)

**Foco:** Os padrões criacionais tratam do **processo de criação de objetos**. Eles fornecem mecanismos para controlar _como_ os objetos são instanciados, tornando o código menos dependente de classes concretas e mais flexível na hora de criar novas instâncias[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20criacionais%20est%C3%A3o%20diretamente,2020). Em vez de espalhar chamadas diretas a construtores (`new`) por todo o código, os padrões criacionais centralizam e abstraem a lógica de instanciamento – garantindo **desacoplamento** entre a lógica de negócio e os detalhes de _quem_ e _como_ um objeto é criado. Isso permite, por exemplo, trocar facilmente as classes concretas instanciadas (fornecendo diferentes implementações em runtime) ou aplicar políticas de criação (como criação sob demanda, pools de objetos, instâncias únicas etc.) sem alterar o código cliente.

**Exemplos de Padrões Criacionais:** _Factory Method_, _Abstract Factory_, _Builder_, _Prototype_ e _Singleton_ são representantes clássicos desta categoria[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=implementa%C3%A7%C3%B5es%20espec%C3%ADficas,2020). Cada um resolve um tipo de problema de criação: por exemplo, _Factory Method_ delega às subclasses a decisão de qual classe concreta instanciar, enquanto um _Builder_ separa a lógica de construção passo-a-passo de objetos complexos da representação final. Já o conhecido _Singleton_ restringe a existência de uma única instância de uma classe, fornecendo um ponto global de acesso a ela[refactoring.guru](https://refactoring.guru/pt-br/design-patterns/creational-patterns#:~:text=objetos%20complexos%20passo%20a%20passo,de%20acesso%20global%20para%20esta)[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Outro%20padr%C3%A3o%20criacional%20muito%20utilizado,1994).

**Analogia do Mundo Real:** Imagine um restaurante elegante. Ao invés de você mesmo **“instanciar”** o prato (cozinhar sua refeição do zero), você faz um pedido ao garçom baseado no menu. A cozinha do restaurante atua como uma fábrica: ela **controla a criação** do prato solicitado, seguindo uma receita específica e usando os recursos necessários, enquanto você simplesmente consome o resultado. Da mesma forma, um _Factory_ ou _Builder_ em código abstrai os detalhes de construção – o cliente só solicita o objeto (como quem faz um pedido) e não precisa saber como ele é criado internamente. Esse controle sobre a criação traz flexibilidade: a cozinha pode mudar **como** prepara o prato (algoritmo de criação) ou trocar ingredientes (classes concretas) sem que o cliente precise saber, análogo a como um Factory Method pode decidir instanciar uma classe diferente conforme a necessidade.

**Exemplo Prático (Código):** Considere que estamos desenvolvendo uma API REST em Java/Spring para gerenciar pedidos de e-commerce. Podemos usar o padrão _Builder_ para montar objetos de pedido de forma flexível, especialmente se houver muitas opções configuráveis:

`// Exemplo simplificado de Builder para criação flexível de um Pedido public class Pedido {     private List<Item> itens;     private String enderecoEntrega;     private boolean entregaExpressa;     // ... outros campos ...      // Construtor privado: uso restrito ao Builder interno     private Pedido() { }      // Getters (omitir setters para imutabilidade)     public List<Item> getItens() { return itens; }     public String getEnderecoEntrega() { return enderecoEntrega; }     public boolean isEntregaExpressa() { return entregaExpressa; }      // Builder interno para construir Pedido     public static class Builder {         private Pedido instancia = new Pedido();         public Builder adicionaItem(Item item) {             instancia.itens.add(item);             return this;         }         public Builder paraEndereco(String end) {             instancia.enderecoEntrega = end;             return this;         }         public Builder entregaExpressa(boolean expressa) {             instancia.entregaExpressa = expressa;             return this;         }         public Pedido build() {             // Validações podem ser feitas aqui antes de construir             return instancia;         }     } }  // Uso do Builder: Pedido pedido = new Pedido.Builder()                     .adicionaItem(new Item("Notebook", 1))                     .adicionaItem(new Item("Mouse", 2))                     .paraEndereco("Rua das Acácias, 123")                     .entregaExpressa(true)                     .build();`

No exemplo acima, o _Builder_ permite configurar gradualmente um objeto `Pedido` antes de instanciá-lo, tornando a criação **flexível** e clara. Esse padrão criacional evita construtores gigantes ou múltiplos construtores sobrecarregados; em vez disso, usamos métodos fluentes para **montar** o objeto conforme necessário. Esse enfoque é útil em aplicações modernas (como no contexto de uma API REST) quando há objetos complexos (por exemplo, objetos de configuração, entidades com muitos campos opcionais, montagem de requests HTTP etc.).

Outra situação comum em backends Java/Spring é o uso de Singletons e fábricas pelo framework. O _Spring_ em si gerencia beans como singletons por padrão (para serviços, repositórios etc.), garantindo que haja uma única instância compartilhada no contexto – isso é essencialmente o padrão Singleton aplicado pelo container de IoC do Spring. Além disso, o contêiner de IoC atua como um **Factory** centralizado de beans: ele instancia os objetos necessários conforme configurações (por exemplo, via anotações ou XML), injetando dependências conforme necessário. Esse mecanismo exemplifica o benefício dos padrões criacionais em **desacoplar** o código da criação direta de objetos – o código de negócio não chama `new` para criar um serviço, ele apenas declara uma dependência, e o framework cuida da criação (aplicando princípios de fábrica e singleton)[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=temos%20o%20Factory%20Method%2C%20Abstract,2020). Assim, mudanças na forma de criar ou configurar esses objetos (por exemplo, trocar a implementação de um serviço por outra) não exigem modificar o código cliente.

## Padrões Estruturais (Structural Patterns)

**Foco:** Padrões estruturais lidam com a **organização e composição de classes e objetos** em estruturas maiores, garantindo que essas estruturas permaneçam eficientes, flexíveis e fáceis de expandir[refactoring.guru](https://refactoring.guru/pt-br/design-patterns/structural-patterns#:~:text=Os%20padr%C3%B5es%20estruturais%20explicam%20como,essas%20estruturas%20flex%C3%ADveis%20e%20eficientes). Em outras palavras, eles definem formas de **montar objetos** para criar funcionalidades mais complexas, promovendo **reutilização de código** e facilitando a manutenção. Em vez de herança pura, muitos padrões estruturais favorecem a **composição** – ou seja, combinar comportamentos de diferentes objetos – para estender funcionalidades sem alterar o código original (seguindo o princípio _Open/Closed_: aberto para extensão, fechado para modificação).

**Exemplos de Padrões Estruturais:** _Adapter_, _Bridge_, _Composite_, _Decorator_, _Facade_, _Flyweight_ e _Proxy_ são exemplos clássicos dessa categoria[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20estruturais%20dizem%20respeito,2020). Cada um aborda um tipo de arranjo estrutural: por exemplo, o _Adapter_ permite que classes com interfaces incompatíveis trabalhem juntas (atua como um “tradutor” entre interfaces); o _Decorator_ envolve um objeto com outro objeto “wrapper” para adicionar dinamicamente novos comportamentos ou responsabilidades; já o _Facade_ fornece uma interface simplificada para um conjunto complexo de subsistemas, tornando mais fácil para o cliente usar funcionalidades avançadas sem lidar com toda a complexidade subjacente.

**Analogia do Mundo Real:** Um exemplo simples é um **adaptador de tomada**. Imagine que você tem um dispositivo eletrônico com plug padrão brasileiro e precisa conectá-lo em uma tomada padrão europeu – os encaixes são incompatíveis. Em vez de **modificar** o dispositivo ou a rede elétrica (o que seria custoso e inflexível), você usa um adaptador de tomada. Esse adaptador age como _intermediário estrutural_: por fora tem o formato compatível com a tomada europeia e por dentro tem o receptáculo para o plug brasileiro, **convertendo** a interface de um para o outro. Da mesma forma, em software, um _Adapter_ permite a colaboração entre objetos de interfaces incompatíveis, **sem alterar** nem o cliente nem o serviço original – ele apenas “traduz” chamadas de um formato para outro[refactoring.guru](https://refactoring.guru/pt-br/design-patterns/structural-patterns#:~:text=Adapter%20Permite%20a%20colabora%C3%A7%C3%A3o%20de,6%20%207%20%20Facade)[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=Analogy%3A%20An%20electrical%20adapter%20lets,compatibility%20without%20changing%20either%20device).

Outra analogia: pense em um **controle remoto universal**. Ele serve como uma fachada (_Facade_) simples para operar diversos dispositivos (TV, DVD, receiver) de forma unificada. Em vez de controlar cada aparelho separadamente com seu controle específico (cada qual com vários botões complexos), a fachada oferece um **ponto de acesso unificado** (um controle com poucos botões genéricos) que internamente aciona os comandos apropriados em cada dispositivo. O cliente (usuário) interage com a fachada simplificada, e não precisa conhecer os detalhes de cada subsistema. Assim funciona o padrão _Facade_: simplifica a utilização de um conjunto complexo de classes, reduzindo o acoplamento do cliente com os detalhes internos.

**Exemplo Prático (Código):** Considere uma aplicação web onde precisamos integrar nosso sistema com um serviço externo de pagamento que possui uma interface diferente da que usamos internamente. Podemos aplicar o padrão _Adapter_ para fazer essa integração:

`// Interface esperada pela nossa aplicação para processar pagamentos interface ProcessadorPagamento {     void pagar(double valor); }  // Classe de um serviço de pagamento externo (por exemplo, PayPal) com interface diferente class PayPalService {     public void makePayment(double amount) {         System.out.println("Pagamento de $" + amount + " realizado via PayPal.");     } }  // Adapter que implementa nossa interface alvo e traduz as chamadas para o serviço externo class PayPalAdapter implements ProcessadorPagamento {     private PayPalService servicoPayPal;     public PayPalAdapter(PayPalService servico) {         this.servicoPayPal = servico;     }     @Override     public void pagar(double valor) {         // Traduz a chamada para o método equivalente do serviço PayPal         servicoPayPal.makePayment(valor);     } }  // Uso do Adapter em um código de negócio: PayPalService apiExterna = new PayPalService(); ProcessadorPagamento pagamento = new PayPalAdapter(apiExterna); pagamento.pagar(150.0);  // Cliente usa a interface ProcessadorPagamento unificada`

No exemplo acima, `ProcessadorPagamento` é a interface esperada pelo nosso domínio (por exemplo, nosso módulo de checkout). A classe `PayPalService` é parte de uma biblioteca externa que tem um método `makePayment`. Para **organizar** a integração sem quebrar nosso código existente, criamos o `PayPalAdapter` que **conecta** as duas interfaces: ele recebe chamadas do método padrão `pagar(double)` e internamente chama `makePayment` do serviço externo. Assim, o restante da aplicação não precisa saber nada sobre os detalhes do PayPal (desacoplamento); podemos futuramente trocar o serviço de pagamento (por outra API) escrevendo um novo adaptador, sem mudar a lógica de negócio que usa `ProcessadorPagamento`. Este é um típico uso de _Adapter_ em uma aplicação web moderna – muito útil ao trabalhar com APIs de terceiros ou módulos legados com interfaces diferentes.

Outro cenário comum para padrões estruturais em backends modernos é o uso de _Decorators_ e _Proxies_. Por exemplo, no Spring Framework, mecanismos de AOP (Programação Orientada a Aspectos) e proxies dinâmicos são usados para adicionar funcionalidades a beans (como logging, segurança, transações) **sem alterar o código original das classes** – isso é o padrão _Proxy_ ou _Decorator_ em ação. Um bean pode ser envolvido por um proxy que intercepta chamadas para adicionar comportamento (p.ex., abrir e fechar transação automaticamente em um método de repositório – típico do Spring Transaction Management). Assim, conseguimos **estender funcionalidades** de forma modular e configurável. Em sistemas de microserviços, podemos usar um _Facade_ no lado do cliente para agregar chamadas a múltiplos serviços diferentes em uma única interface (um **API Gateway** frequentemente atua como uma fachada, simplificando o acesso a vários serviços internos). Esses exemplos mostram como padrões estruturais ajudam na **reutilização e expansão** do sistema, organizando componentes de maneira adaptável às mudanças.

## Padrões Comportamentais (Behavioral Patterns)

**Foco:** Padrões comportamentais se concentram na **interação e comunicação eficaz entre objetos**, definindo como responsabilidades são distribuídas e como algoritmos podem ser encapsulados e intercambiados dentro do sistema[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20comportamentais%20lidam%20com,1994). Diferentemente dos padrões criacionais (que criam objetos) e estruturais (que os compõem), os comportamentais estabelecem **formas flexíveis de os objetos colaborarem**, seja trocando mensagens, orquestrando fluxos de execução ou reagindo a mudanças uns dos outros. Em suma, eles ajudam a **desacoplar o “quem faz o quê”** – permitem variar algoritmos, sequências de operações ou caminhos de comunicação sem alterar diretamente os objetos envolvidos, muitas vezes conseguindo substituição dinâmica de comportamentos em runtime.

**Exemplos de Padrões Comportamentais:** _Strategy_, _Observer_, _Command_, _Chain of Responsibility_, _State_, _Template Method_, _Mediator_, _Iterator_, _Visitor_, _Memento_, entre outros[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=,of%20small%20types%20and%20indirection)[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20comportamentais%20lidam%20com,1994). Alguns focam em encapsular algoritmos/funções específicas – por exemplo, _Strategy_ define **uma família de algoritmos** e as encapsula em classes separadas, tornando-as intercambiáveis em tempo de execução, de modo que o algoritmo possa variar independentemente do cliente que o usa (sem if/else espalhados)[macoratti.net](https://macoratti.net/22/01/c_strategy1.htm#:~:text=C%23%20,entender%20o%20que%20isso%20significa). _Template Method_ por sua vez define o **esqueleto de um algoritmo** em uma classe base e permite que subclasses substituam etapas específicas, promovendo reutilização de fluxo de controle comum com personalização de detalhes. Outros padrões desta categoria tratam da comunicação entre partes do sistema – _Observer_ estabelece um relacionamento de notificação (um sujeito notifica múltiplos observadores quando um evento ocorre, em vez de os observadores terem que consultar ativamente), enquanto _Mediator_ centraliza a comunicação entre vários objetos para evitar dependências caóticas (objetos se comunicam através do mediador, em vez de todos conhecerem todos). Já o _Chain of Responsibility_ (Cadeia de Responsabilidade) passa uma solicitação através de uma cadeia de manipuladores até que um deles a processe, permitindo montar sequências flexíveis de processamento (cada handler decide se atende ou delega para o próximo). O _Command_ encapsula uma requisição ou operação como um objeto, permitindo enfileirar, fazer log ou desfazer operações facilmente, além de desacoplar quem solicita a ação de quem a executa.

**Analogia do Mundo Real:** Uma analogia ilustrativa para _Observer_ é a assinatura de uma revista ou newsletter: a **revista** (Objeto _Subject_) sabe quem são seus assinantes (_Observers_) e os notifica automaticamente a cada nova edição (evento). Os assinantes não precisam ficar ligando para a editora perguntando "tem novidade?" – em vez disso, quando algo acontece, eles **recebem uma notificação**. Isso espelha exatamente o padrão _Observer_: um sujeito mantém uma lista de observadores e os informa de mudanças de estado[refactoring.guru](https://refactoring.guru/pt-br/design-patterns/behavioral-patterns#:~:text=salve%20e%20restaure%20o%20estado,que%20um%20objeto%20altere%20seu).

Para _Strategy_, pense em uma loja online com diferentes formas de pagamento (cartão de crédito, PayPal, boleto). Todas realizam o pagamento, mas cada uma com um **algoritmo** ou processo diferente. Podemos definir uma interface comum (ex: `PagamentoStrategy`) e ter implementações concretas para cada método de pagamento. Na hora de finalizar a compra, o sistema **escolhe dinamicamente** qual estratégia aplicar, conforme preferência do cliente ou disponibilidade do serviço. Assim, o algoritmo de pagamento é intercambiável – hoje podemos adicionar, por exemplo, "Pix" como uma nova estratégia, sem modificar o código da finalização em si. Essa analogia demonstra como _Strategy_ encapsula algoritmos distintos sob uma mesma abstração.

Outra analogia, para _Chain of Responsibility_: Suponha um atendimento ao cliente com níveis de suporte (suporte nível 1, 2, 3). Um cliente abre um chamado; o atendente de nível 1 tenta resolver. Se não conseguir, ele **passa a responsabilidade adiante** para o nível 2, e assim por diante, até alguém solucionar. Essa “cadeia” de passagem de responsabilidade reflete o padrão – cada handler na cadeia decide se trata ou escalona o pedido. O cliente que abriu o chamado não sabe _quem_ vai resolver, nem precisa saber – apenas sabe que seu problema será tratado por alguém qualificado na sequência adequada. Esse padrão reduz acoplamento entre solicitante e resolvedor, e permite variar facilmente a cadeia (adicionar novos níveis, mudar a ordem) sem mudar o código do solicitante.

**Exemplo Prático (Código):** Para ilustrar, vejamos o _Strategy_ em um contexto de backend web moderno. Imagine um serviço de autenticação que pode usar diferentes estratégias de login (LDAP, OAuth, autenticação própria):

`// Definição da estratégia de autenticação interface AuthStrategy {     boolean autenticar(String usuario, String senha); }  // Implementações concretas de estratégias de autenticação class LDAPAuthStrategy implements AuthStrategy {     public boolean autenticar(String u, String s) {         // Lógica de autenticação via servidor LDAP         System.out.println("Autenticando " + u + " via LDAP...");         return true; // simplificação     } } class OAuthAuthStrategy implements AuthStrategy {     public boolean autenticar(String u, String s) {         // Lógica de autenticação via serviço OAuth (ignorando 'senha' localmente)         System.out.println("Autenticando " + u + " via OAuth...");         return true;     } } class LocalAuthStrategy implements AuthStrategy {     public boolean autenticar(String u, String s) {         // Lógica de autenticação local (ex: verificar senha em banco de dados)         System.out.println("Autenticando " + u + " no banco local...");         return "senha123".equals(s);      } }  // Contexto que usa uma estratégia de autenticação escolhida class ServicoAutenticacao {     private AuthStrategy estrategia;     public void setEstrategia(AuthStrategy estrategia) {         this.estrategia = estrategia;     }     public boolean login(String usuario, String senha) {         // Delegar a lógica de autenticação para a estratégia configurada         return estrategia.autenticar(usuario, senha);     } }  // ... Em algum lugar do código de configuração ou fluxo de execução: ServicoAutenticacao authService = new ServicoAutenticacao(); // Suponha que determinamos a estratégia com base em configuração: authService.setEstrategia(new OAuthAuthStrategy()); boolean sucesso = authService.login("joao", "qualquerCoisa"); // Poderíamos trocar para outra estratégia facilmente, por ex: authService.setEstrategia(new LDAPAuthStrategy());`

Nesse exemplo, `ServicoAutenticacao` age como o contexto que pode usar diferentes estratégias de autenticação. Dependendo do ambiente ou configuração (digamos, autenticação local para testes, LDAP para ambiente corporativo, OAuth para integração com Google/Facebook etc.), selecionamos a implementação apropriada de `AuthStrategy`. Cada estratégia encapsula um **algoritmo de autenticação** distinto. O código de login em si não precisa de _ifs_ para cada método de autenticação; ele apenas delega à estratégia atual. Isso torna o sistema **flexível**: adicionar um novo método de autenticação (por exemplo, SAML) requer apenas criar outra classe implementando `AuthStrategy` – nenhuma mudança é necessária em `ServicoAutenticacao` ou nos clientes que o usam. Este é o poder dos padrões comportamentais: variação de comportamento através de composição e delegação, em vez de condicionais rígidos ou acoplamento forte a implementações específicas.

No contexto de aplicações web com Spring, também vemos vários padrões comportamentais em ação. Por exemplo, o **Interceptor/Cadeia de Filtros** em uma aplicação Spring MVC ou Spring Security é um caso de _Chain of Responsibility_: a requisição HTTP passa por uma cadeia de filtros (autenticação, autorização, logging, compressão, etc.) onde cada filtro decide processar ou passar adiante. O remetente da requisição (o cliente HTTP) não sabe quantos passos de processamento existem – a arquitetura é flexível para inserir ou remover filtros. Outro exemplo: o mecanismo de **eventos do Spring** (Application Events) implementa o padrão _Observer_ – componentes podem publicar eventos e outros componentes (_listeners_) inscritos serão notificados automaticamente, sem os dois estarem diretamente conectados. Isso permite uma comunicação desacoplada dentro da aplicação (por exemplo, após criar um pedido, um evento de “PedidoCriado” pode notificar diversos subsistemas – faturamento, estoque, notificações – cada um reagindo de forma independente). Esses padrões comportamentais garantem que **algoritmos e fluxos de comunicação** fiquem encapsulados, podendo mudar independentemente das partes que os utilizam ou disparam.

## Comparação e Quando Usar Cada Categoria

Em resumo, cada grupo de padrões atende a um tipo distinto de preocupação de design. Podemos delinear **quando é mais apropriado considerar padrões de cada categoria**:

- **Padrões Criacionais:** Use quando o modo de criar objetos está gerando _dificuldade de manutenção ou expansão_. Por exemplo, se você percebe código duplicado instanciando classes, lógica complexa para escolher qual classe instanciar, ou deseja ocultar detalhes de construção dos clientes. Esses padrões são ideais para obter **flexibilidade na instanciação** – trocar implementações em runtime, garantir instância única, ou construir objetos complexos sem expor sua lógica interna[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=Problem%20they%20solve%3A%20How%20to,coupling%20code%20to%20concrete%20classes). _Exemplos:_ quando se deseja suportar múltiplas variantes de um produto (use _Factory Method_ ou _Abstract Factory_), construir um objeto passo a passo (_Builder_), ou assegurar um ponto global de acesso (_Singleton_). Em aplicações web, considere padrões criacionais se a criação de componentes (conexões, entidades, serviços) precisa ser centralizada ou desacoplada (p.ex., uso de fábricas para DAO/Repositories, ou builder para montar objetos de configuração).
    
- **Padrões Estruturais:** Use quando há _dificuldades de integrar ou estruturar partes do sistema_ de forma coesa. Se componentes não se encaixam devido a interfaces diferentes, ou se você precisa estender funcionalidades de classes sem herança múltipla, esses padrões ajudam a **organizar e reutilizar código** de maneira elegante[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=,obscure%20control%20flow%20if%20overused). Também se aplicam quando se quer **facilitar expansão** do sistema sem modificações drásticas. _Exemplos:_ quando se integra um módulo legado ou biblioteca de terceiros (aplique um _Adapter_ para compatibilizar interfaces), quando se precisa adicionar comportamentos extras a objetos de forma transparente (_Decorator_ ou proxies), ou ao projetar uma estrutura em árvore como menus, arquivos ou componentes gráficos (_Composite_ facilita tratar componentes individuais e composições de forma uniforme). Em projetos backend, padrões estruturais aparecem ao criar fachadas para serviços externos (unificando chamadas complexas) ou proxies de cache/segurança que controlam acesso a recursos compartilhados.
    
- **Padrões Comportamentais:** Use quando o desafio está em _como os objetos interagem ou em como variar fluxos de execução/algoritmos_ de forma flexível. Se muitas classes precisam se comunicar sem alto acoplamento, ou se algoritmos de negócio podem mudar frequentemente ou ter múltiplas implementações, os padrões comportamentais fornecem soluções para **encapsular essas interações e lógicas**[gofpattern.com](https://www.gofpattern.com/design-patterns/module2/three-types-design-patterns.php#:~:text=Problem%20they%20solve%3A%20How%20objects,vary%20algorithms%20without%20tight%20coupling). _Exemplos:_ quando é necessário notificar automaticamente várias partes do sistema sobre um evento (_Observer_, ideal para sistemas de evento/monitoramento), quando se quer trocar dinamicamente a lógica de um processo (_Strategy_, para políticas de negócio configuráveis em runtime), ou para orquestrar uma sequência variável de etapas (_Chain of Responsibility_ ou _Command_, para workflow flexível e possibilidade de undo/redo). Em aplicações modernas, aplique padrões comportamentais para implementar regras de negócio plugáveis (por ex., diferentes estratégias de cálculo de frete ou promoção), para desacoplar emissores e receptores de mensagens (eventos de domínio, filas etc.), ou para gerenciar estado complexo de objetos (padrão _State_ pode ajudar a evitar inúmeros _ifs_ baseados no estado interno de um objeto).
    

Em suma, os **padrões criacionais** abordam _quem_ cria os objetos e _como_ garantir flexibilidade nesse processo; os **padrões estruturais** abordam _como_ os objetos estão montados e conectados, facilitando _reutilização e expansão_ através da composição; e os **padrões comportamentais** focam em _como_ objetos **colaboram**, distribuindo responsabilidades e definindo fluxos de interação e de algoritmos de forma flexível. Ao reconhecer em qual dessas dimensões está o problema de design que você enfrenta – criação, estrutura ou comportamento – você pode escolher a categoria (e então o padrão específico) mais adequada para **resolver o problema de forma elegante e comprovada**. Assim, desenvolvedores backend podem aplicar esses conceitos em arquiteturas modernas (como microserviços, aplicações Spring, APIs REST) para produzir sistemas mais **mantíveis, extensíveis e robustos**, aproveitando soluções testadas pelo tempo para problemas recorrentes no desenvolvimento de software[leaders.tec.br](https://leaders.tec.br/artigo/analise-comparativa-de-padroes-distincoes-e-aplicacoes-dos-padroes-comportamentais-criacionais-e-estruturais#:~:text=Os%20padr%C3%B5es%20de%20design%20fornecem,desenvolvimento%20mais%20%C3%A1gil%20e%20sustent%C3%A1vel).