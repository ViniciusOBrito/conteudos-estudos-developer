# Garbage Collection
#runtime #memory #plataforma

---

## 1. O que é Garbage Collection

### [[12. Plataformas e Sistemas Operacionais/Garbage Collector/1.1 Conceito Fundamental.md|1.1 Conceito Fundamental]]

- Garbage Collection (GC) como **mecanismo automático de gerenciamento de memória**
    
- Identificação e liberação de objetos **inacessíveis**
    
- GC como parte intrínseca do **runtime / máquina virtual**
    
- Abstração da alocação e desalocação manual
    

### 1.2 [[12. Plataformas e Sistemas Operacionais/Garbage Collector/1.2 Responsabilidade do Runtime.md|Responsabilidade do Runtime]]

- GC implementado pelo runtime (JVM, CLR, V8, CPython)
    
- Linguagens apenas **exponenciam o modelo**, não implementam o GC
    
- Diferença entre:
    
    - Linguagem gerenciada
        
    - Runtime gerenciado
        

### 1.3 Modelo de Vida do Objeto

- Objetos vivos (reachable)
    
- Objetos elegíveis para coleta (unreachable)
    
- Reachability Graph
    
- GC Roots como ponto de partida da análise
    

### 1.4 Garbage Collection vs Memory Leak

- Vazamento real (objetos inacessíveis não coletados — raro)
    
- Vazamento lógico (objetos ainda referenciados indevidamente)
    
- Relação entre GC, referências estáticas e caches mal projetados
    
- GC **não corrige mau design**
    

---

## 2. Heap, Stack e Modelo de Alocação

### 2.1 Stack Memory

- Memória de execução de métodos
    
- Variáveis locais e parâmetros
    
- Ciclo de vida vinculado ao escopo
    
- Liberação automática (LIFO)
    

### 2.2 Heap Memory

- Armazenamento de objetos
    
- Memória compartilhada entre threads
    
- Controlada pelo Garbage Collector
    
- Crescimento dinâmico
    

### 2.3 Alocação de Objetos

- Alocação no Heap
    
- Ponteiros de referência na Stack
    
- Escape Analysis (em runtimes modernos)
    

### 2.4 GC Roots

- Stack frames
    
- Threads ativas
    
- Variáveis estáticas
    
- JNI / referências nativas
    
- Contextos de runtime
    

### 2.5 Escopo, Referências e Elegibilidade

- Perda de referência
    
- Finalização de escopo
    
- Impacto de closures / lambdas
    
- Objetos retidos indiretamente
    

### 2.6 Gerações de Memória (Visão Conceitual)

- Young Generation
    
- Old Generation
    
- Hipótese geracional (most objects die young)
    

### 2.7 Heap Sizing

- Heap mínimo e máximo
    
- Over-allocation vs under-allocation
    
- Impacto no GC throughput e latência
    

---

## 3. Quando o GC Atua

### 3.1 Eventos de Alocação

- Alocação contínua de objetos
    
- Saturação do espaço jovem
    
- Promoção para gerações mais antigas
    

### 3.2 Pressão de Memória

- Heap approaching limit
    
- Falha de alocação
    
- Gatilhos de coleta
    

### 3.3 Ciclo de Garbage Collection

- Root scanning
    
- Marcação de objetos vivos
    
- Coleta e compactação
    

### 3.4 Tipos de Coleta

- Minor GC (Young Generation)
    
- Major GC (Old Generation)
    
- Full GC (heap completo)
    

### 3.5 Pausas de Execução

- Stop-the-World (STW)
    
- Pausas síncronas vs concorrentes
    
- Efeitos colaterais em threads de aplicação
    

### 3.6 Ciclo de Vida de um Objeto

- Criação
    
- Uso
    
- Promoção
    
- Inatividade
    
- Coleta
    

---

## 4. Estratégias e Algoritmos de GC

### 4.1 Mark-and-Sweep

- Marcação de objetos alcançáveis
    
- Limpeza dos não alcançáveis
    
- Fragmentação de memória
    

### 4.2 Mark-and-Compact

- Compactação após varredura
    
- Redução de fragmentação
    
- Maior custo de CPU
    

### 4.3 Copying Collection

- Cópia entre espaços
    
- Alta eficiência para objetos jovens
    
- Base de Survive Spaces
    

### 4.4 Reference Counting

- Contador de referências por objeto
    
- Coleta imediata
    
- Problema de ciclos
    

### 4.5 Generational Garbage Collection

- Separação por tempo de vida
    
- Promoção entre gerações
    
- Principal estratégia dos runtimes modernos
    

### 4.6 Concurrent GC

- Coleta paralela à execução da aplicação
    
- Redução de pausas longas
    
- Aumento de complexidade
    

### 4.7 Incremental GC

- Divisão da coleta em pequenas etapas
    
- Melhor previsibilidade
    
- Comum em ambientes interativos
    

---

## 5. Garbage Collection por Plataforma

---

### 5.1 JVM (Java)

#### Coletores

- Serial GC
    
- Parallel GC
    
- CMS (Concurrent Mark-Sweep)
    
- G1 GC
    
- ZGC
    
- Shenandoah
    

#### Organização de Memória

- Young Generation
    
    - Eden Space
        
    - Survivor Spaces (S0 / S1)
        
- Old Generation
    
- Metaspace
    

#### Características

- Altamente configurável
    
- GC tuning como atividade crítica
    

---

### 5.2 .NET / CLR

#### Modelo

- GC geracional
    
- Compactador por padrão
    

#### Gerações

- Generation 0
    
- Generation 1
    
- Generation 2
    

#### Large Object Heap (LOH)

- Objetos grandes
    
- Coleta menos frequente
    
- Possível fragmentação
    

#### Modos de GC

- Workstation GC
    
- Server GC
    

---

### 5.3 Python

#### Reference Counting

- Coleta imediata
    
- Overhead constante
    

#### Cyclic Garbage Collector

- Detecção de ciclos
    
- Execução periódica
    
- Menos previsível
    

---

## 6. Trade-offs do Garbage Collector

### 6.1 Latência vs Throughput

- Baixa latência → mais overhead
    
- Alto throughput → pausas maiores
    

### 6.2 Pausas

- Pausas curtas e frequentes
    
- Pausas longas e raras
    

### 6.3 Consumo de Recursos

- Uso adicional de CPU
    
- Uso adicional de memória
    

### 6.4 GC Tuning

- Ajuste fino do heap
    
- Escolha de coletor
    
- Análise de GC logs
    

### 6.5 Configuração Inadequada

- Heap subdimensionado
    
- Heap superdimensionado
    
- Geração mal equilibrada
    

---

## 7. Quando Garbage Collection Vira Problema

### 7.1 Tipos de Sistema

- Sistemas low-latency
    
- Sistemas near real-time
    
- Engines de jogos
    
- Trading systems
    

### 7.2 Padrões de Código Problemáticos

- Alocação excessiva
    
- Objetos de vida longa
    
- Estruturas estáticas globais
    
- Cache sem política de descarte
    

### 7.3 GC como Gargalo Arquitetural

- Impacto em microserviços
    
- Amplificação de latência
    
- Efeito cascata em sistemas distribuídos
    

### 7.4 Alternativas e Mitigações

- Object pooling
    
- Reuso de estruturas
    
- Off-heap memory
    
- Linguagens sem GC em casos extremos
